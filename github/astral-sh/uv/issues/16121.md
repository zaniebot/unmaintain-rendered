---
number: 16121
title: Add list-scripts subcommand similar to pydoit.org or taskfile.dev
type: issue
state: open
author: scr-oath
labels:
  - enhancement
assignees: []
created_at: 2025-10-03T20:33:02Z
updated_at: 2025-10-27T18:01:40Z
url: https://github.com/astral-sh/uv/issues/16121
synced_at: 2026-01-07T12:31:16-06:00
---

# Add list-scripts subcommand similar to pydoit.org or taskfile.dev

---

_Issue opened by @scr-oath on 2025-10-03 20:33_

### Summary

I use <https://pydoit.org> or <https://taskfile.dev> in various projects as a means of declaring things that developers (or CI/CD) can do for frequent/useful tasks.

We recently started using or encountering uv/uvx in many places, and using console scripts to declare things to be run with `uv run script-name` e.g. It would be really nice if uv could be as helpful as other task-declaration systems by listing out the scripts and their descriptions.

I asked Claude Code to whip up something "list-commands" for my project, but it seems like this could be part of the `uv/uvx` system (converted to Rust if need be).

Essentially, it just examines the pyproject.toml for the commands, and then each module for its pydoc comments to pull out the first line if summary or entirety if `--detailed`

```python
"""
List available CLI commands with descriptions.

Discovers console scripts from pyproject.toml and displays their documentation.
"""

import click
import importlib
import inspect
import tomllib
from pathlib import Path
from typing import Optional


def get_project_root() -> Path:
    """Find project root by looking for pyproject.toml."""
    current = Path(__file__).resolve()
    for parent in [current] + list(current.parents):
        if (parent / "pyproject.toml").exists():
            return parent
    raise FileNotFoundError("Could not find pyproject.toml")


def load_console_scripts() -> dict[str, str]:
    """Load console scripts from pyproject.toml."""
    project_root = get_project_root()
    pyproject_path = project_root / "pyproject.toml"

    with open(pyproject_path, "rb") as f:
        config = tomllib.load(f)

    scripts = config.get("project", {}).get("scripts", {})
    return scripts


def get_command_info(module_path: str, entry_point: str) -> tuple[Optional[str], Optional[str]]:
    """
    Get command documentation by importing the module.

    Args:
        module_path: Module path like "agentic_sales_spanner.profiling.run_profile"
        entry_point: Entry point function name like "main"

    Returns:
        Tuple of (brief_description, full_docstring)
    """
    try:
        module = importlib.import_module(module_path)
        func = getattr(module, entry_point, None)

        if func is None:
            return None, None

        # Get docstring from the function or module
        docstring = inspect.getdoc(func)
        if not docstring:
            docstring = inspect.getdoc(module)

        if not docstring:
            return "No description available", None

        # Split into brief (first line) and full
        lines = docstring.strip().split("\n")
        brief = lines[0].strip()
        full = docstring.strip()

        return brief, full

    except Exception as e:
        return f"Error loading: {e}", None


@click.command()
@click.option(
    "--detailed",
    "-d",
    is_flag=True,
    help="Show detailed descriptions for all commands"
)
@click.option(
    "--command",
    "-c",
    type=str,
    help="Show detailed info for a specific command"
)
def main(detailed: bool, command: Optional[str]):
    """
    List available CLI commands with descriptions.

    Parses pyproject.toml to discover console scripts and displays their
    documentation from module/function docstrings.

    Examples:
        uv run list-commands              # Brief list of all commands
        uv run list-commands --detailed   # Detailed list of all commands
        uv run list-commands -c analyze-brief  # Details for one command
    """
    try:
        scripts = load_console_scripts()
    except Exception as e:
        click.echo(f"Error loading commands: {e}", err=True)
        return 1

    if not scripts:
        click.echo("No console scripts found in pyproject.toml", err=True)
        return 1

    # Filter to specific command if requested
    if command:
        if command not in scripts:
            click.echo(f"Command '{command}' not found", err=True)
            click.echo(f"\nAvailable commands: {', '.join(sorted(scripts.keys()))}")
            return 1
        scripts = {command: scripts[command]}
        detailed = True  # Always show details for single command

    # Show header
    if not command:
        click.echo("=" * 80)
        click.echo("AVAILABLE COMMANDS")
        click.echo("=" * 80)
        click.echo()

    # Collect and display commands
    commands_info = []
    for cmd_name in sorted(scripts.keys()):
        entry = scripts[cmd_name]
        module_path, entry_point = entry.split(":")
        brief, full = get_command_info(module_path, entry_point)
        commands_info.append((cmd_name, brief, full))

    if detailed:
        # Detailed format: stanzas with full docstrings
        for i, (cmd_name, brief, full) in enumerate(commands_info):
            if i > 0:
                click.echo()

            click.echo(f"ðŸ“¦ {cmd_name}")
            click.echo("-" * 80)

            if full:
                # Format docstring nicely
                lines = full.split("\n")
                for line in lines:
                    click.echo(f"  {line}")
            else:
                click.echo(f"  {brief or 'No description available'}")

            click.echo()
            click.echo(f"  Usage: uv run {cmd_name} [OPTIONS]")
            click.echo()
    else:
        # Brief format: table-like list
        max_cmd_len = max(len(cmd) for cmd, _, _ in commands_info)

        for cmd_name, brief, _ in commands_info:
            brief_text = brief or "No description available"
            # Truncate if too long
            if len(brief_text) > 70:
                brief_text = brief_text[:67] + "..."
            click.echo(f"  {cmd_name:<{max_cmd_len}}  {brief_text}")

        click.echo()
        click.echo(f"Total: {len(commands_info)} commands")
        click.echo()
        click.echo("Use --detailed or -d for full descriptions")
        click.echo("Use --command <name> or -c <name> for details on one command")

    return 0


if __name__ == "__main__":
    main()
```

### Example

_No response_

---

_Label `enhancement` added by @scr-oath on 2025-10-03 20:33_

---

_Comment by @mikenerone on 2025-10-27 18:01_

Is this different from #5903?

---
