---
number: 1897
title: Generating via derive leaves in different state than via into_app()
type: issue
state: closed
author: alerque
labels:
  - C-bug
assignees: []
created_at: 2020-05-02T22:02:19Z
updated_at: 2020-05-03T07:27:28Z
url: https://github.com/clap-rs/clap/issues/1897
synced_at: 2026-01-07T12:31:17-06:00
---

# Generating via derive leaves in different state than via into_app()

---

_Issue opened by @alerque on 2020-05-02 22:02_

Experimenting with the current Git HEAD and using `#[derive(Clap)]`, I'm getting different results that I expect. The docs are still a bit sparse on these interfaces so there may be something in transition, but for the sake of people like me who will be trying to port from StructOpt I'm raising this issue so there are no surprises.

Generating an app from a Struct works much as expected this way:

```rust
#[derive(Clap)]
struct Cli {
    #[clap(short, long)]
    debug: bool,
}

let args = Cli::parse();

if args.debug {}
```

The result is pretty staight forward. The `args` variable holds a very simple stuct with values as might be expected (Strings, bools, etc.). This works the same as in StructOpt.

However as best I can make out from the docs this _should_ be equivalent of this:

```rust

#[derive(Clap)]
struct Cli {
    #[clap(short, long)]
    debug: bool,
}

let app = Cli::into_app();
let args = app.get_matches()

if args.debug {} // Err!
```

In this scenario `args` has been made into a instance of ArgMatches. This is documented, but the results seem inconsistent. There doesn't seem to be any way to get the simpler struct with the values in place from the `into_app().get_matches()` method and there  doesn't seem to be a way to get the ArgMatches from the `parse()` method.

---

_Label `T: bug` added by @alerque on 2020-05-02 22:02_

---

_Comment by @CreepySkeleton on 2020-05-02 23:41_

You seem to imagined the whole process having two steps:

1. Given a struct (enum, collection of structs, irrelevant for the purposes of this explanation), generate a corresponding  `clap::App` (`IntoApp::into_app` in your mental model, ).
2. Fill the struct with values taken form CL args, using the `App` as scheme (`App::get_matches` in your understanding, INCORRECT).

Did you notice that the second step is somehow over-complicated? This is because it's not just _one_ step but _two_. This is how the process looks in reality:

1. Given a struct (enum, collection of structs, irrelevant for the purposes of this explanation), generate a corresponding  `clap::App`. (`IntoApp::into_app`, your image is correct here).
2. Parse the Cl args into an internal dictonary-like representation, `clap::ArgMatches`. This representation allows you for querying the desired args via `value_of` and such but all it can give you is `&str/&OsStr`. It has _zero_ idea of what your struct looks like, in fact, it's derive-independed. (`App::get_matches` , your image is also correct here, but this is not the last step).
3. Using querying methods above, along with parsers you can specify with the help of `#[clap(parse(...))]` attributes, extract the needed values in their string form and convert the strings into the desired types, populating the fields along the way. (`FromArgMatches::from_arg_matches`, the missing piece).

To glue it all together, your code should look like:
```rust
#[derive(Clap)]
struct Cli {
    #[clap(short, long)]
    debug: bool,
}

let app = Cli::into_app();
let matches = app.get_matches()
let args = Cli::from_arg_matches(&m);

if args.debug {} // Ok!
```

My internal teacher hopes this clarifies the picture.

---

_Closed by @CreepySkeleton on 2020-05-02 23:41_

---

_Comment by @alerque on 2020-05-03 07:27_

Thanks @CreepySkeleton! The teacher vibes are strong with you. That finally makes sense.

I understand the state of documentation in Git HEAD isn't expected to be ready for the 3.0 release just yet, but for the sake of other people that will be migrating from StructOpt it might be worth going out of the way a little bit to clarify how `Cli::parse()` is equivalent to those three stages. Many places in the docs seem to suggest that `app.get_matches()` is the state people are expected to start _using_ their args from and I suspect I won't be the only one surprised by this.

---
