---
number: 5796
title: "Add `value_from_arg_matches` for compatibility with `config-rs`"
type: issue
state: closed
author: 0xForerunner
labels:
  - C-enhancement
assignees: []
created_at: 2024-10-31T17:12:00Z
updated_at: 2024-10-31T19:45:50Z
url: https://github.com/clap-rs/clap/issues/5796
synced_at: 2026-01-07T12:31:17-06:00
---

# Add `value_from_arg_matches` for compatibility with `config-rs`

---

_Issue opened by @0xForerunner on 2024-10-31 17:12_

### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the [open](https://github.com/clap-rs/clap/issues) and [rejected](https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed) issues

### Clap Version

4.5.20

### Describe your use case

I would like to be able to use clap as a source for the `config-rs` crate. I think this is a pretty common use case for a lot of people.

### Describe the solution you'd like

I think a reasonable way to do this would be to provide a function like this:

```rust
pub trait FromArgMatches: Sized {
    fn value_from_arg_matches( __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Value, clap::Error>
```

where `Value` is a type similar to `serde_json::Value` or `config-rs::Value`

It would then be pretty trivial to implement `config-rs::Source` for this new type. The end result could look something like this:

```rust
#[derive(Default, Parser, Debug, Serialize, Deserialize)]
struct Opts {
    #[clap(short, long)]
    my_arg: u64,
}

let args_matches = Opts::command().ignore_errors(true).get_matches();
let value = Opts::value_from_arg_matches(&args_matches)?;
let config = config::Config::builder()
    .add_source(config::File::from(path).required(true))
    .add_source(value)
    .build()?;

let opts = deserialize(config)?;
```

### Alternatives, if applicable

_No response_

### Additional Context

_No response_

---

_Label `C-enhancement` added by @0xForerunner on 2024-10-31 17:12_

---

_Comment by @epage on 2024-10-31 17:19_

`ArgMatches` can store any type.  To put it into a `Value` would require limiting what is stored.  There is also nothing privileged about this and this wouldn't be useful for any other part of clap.  With all of that combined, I feel like this would best live in a separate crate.  As such, I'm going to close this for now.  If there is a reason we should reconsider this, let us know!

btw brainstorming on how to deal with layered config is happening in #2763

---

_Closed by @epage on 2024-10-31 17:19_

---

_Comment by @0xForerunner on 2024-10-31 19:23_

Hey @epage thanks for taking a look. I think perhaps I wasn't entirely clear.

I don't think it's possible to implement this outside this crate as the behaviour is specific to `FromArgMatches`.

It's not possible to go form `ArgMatches` to `Value` without some additional context, and attributes like #[clap(flatten)] changes how things are laid out. 

This definitely isn't the only way get layered configuration to work, but I thought it might be a fairly easy one to implement.

---

_Comment by @epage on 2024-10-31 19:33_

Ok, so you are wanting to leverage `FromArgMatches` to know how to generate a value.  The problem there is that we'd then need to extend that trait to support this and create a whole new system for converting the user's data type to a `Value`.  This is starting to instead sound like deriving `serde::Deserialize` on the type.

---

_Comment by @0xForerunner on 2024-10-31 19:45_

Admittedly I'm unfamiliar with how complex deriving `FromArgMatches` really is, and I was hoping it would be a small change to return an incomplete `Value` instead of `Self`. 

There is some similarity to deriving `Deserialize`, with the main difference here being that `value_from_arg_matches` would return an _incomplete_ value representation of `Self`, which would later be merged using `config-rs`.

---
