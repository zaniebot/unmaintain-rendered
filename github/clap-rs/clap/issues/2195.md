---
number: 2195
title: "Auto-derivation with `multiple_occurrences`"
type: issue
state: closed
author: fosskers
labels:
  - C-bug
  - A-derive
assignees: []
created_at: 2020-10-31T18:38:52Z
updated_at: 2021-10-21T21:05:07Z
url: https://github.com/clap-rs/clap/issues/2195
synced_at: 2026-01-07T12:31:17-06:00
---

# Auto-derivation with `multiple_occurrences`

---

_Issue opened by @fosskers on 2020-10-31 18:38_

This issue is related to the following discussion: https://github.com/clap-rs/clap/discussions/2192 . The original issue is explained it detail there. I was asked to open an issue, since there may be a UI/UX change that can be made. Below is runnable code that demonstrates the problem.

### Code and Behaviour

This first example shows the original form of the code.

```rust
use clap::Clap;

#[derive(Clap, Debug)]
struct Args {
    /// Some cleaning operation.
    #[clap(long, short)]
    clean: bool,
}

fn main() {
    let args = Args::parse();

    println!("{:#?}", args);
}
```
When we run this, we see that `--clean` is a flag. Either on or off.
```
> cargo run -- -h
clap-ma 

USAGE:
    clap-ma [FLAGS]

FLAGS:
    -c, --clean      Some cleaning operation
    -h, --help       Prints help information
    -V, --version    Prints version information
```
If we try to set `--clean` multiple times, we get an error as expected:
```
> cargo run -- -cc
error: The argument '--clean' was provided more than once, but cannot be used multiple times

USAGE:
    clap-ma [FLAGS]

For more information try --help
```
Now let's set `multiple_occurrences = true`:
```rust
use clap::Clap;

#[derive(Clap, Debug)]
struct Args {
    /// Some cleaning operation.
    #[clap(long, short, multiple_occurrences = true)]
    clean: bool,
}

fn main() {
    let args = Args::parse();

    println!("{:#?}", args);
}
```
This compiles fine, but help output doesn't change. `-c` can be passed more than once, but since the field is a single `bool`, nothing really changes. You might think that setting the field instead to `u8` or `Vec<bool>` would then represent the *count* of the appearances of the flag, but doing so instead turns it into an arg-accepting "option":
```
> cargo run -- -h
clap-ma 

USAGE:
    clap-ma --clean <clean>...

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --clean <clean>...    Some cleaning operation
colin@yumi ~/c/r/clap-ma (master)> cargo run -- -c
error: The argument '--clean <clean>...' requires a value but none was supplied

USAGE:
    clap-ma --clean <clean>...

For more information try --help
```

### Steps to reproduce the issue

1. Run the first example with `cargo run -- -h`
2. See the expected output: `--clean` is a "flag".
3. Activate `multiple_occurrences`.
4. Notice that `--help` output remains the same.
5. Change the field type to a non-bool.
6. Notice that `--clean` becomes an arg-accepting "option".

### Version

* **Rust**: `rustc 1.47.0 (18bf6b4f0 2020-10-07)`
* **Clap**: `3.0.0-beta.2`

### Actual Behavior Summary

*See the above.*

I am attempting to represent flags that can appear multiple times in my [port of the Aura project](https://github.com/fosskers/aura/issues/657) to Rust, but I wish to do so via the auto-derived `Clap` trait, which is much cleaner than handwriting the `App` and `Arg`s.

### Debug output

The following shows `multiple_occurrences = true`, but the field is a single `bool`:

<details>
<summary> Debug Output </summary>
<pre>
<code>
> cargo run -- -cc
   Compiling clap v3.0.0-beta.2
   Compiling clap-ma v0.1.0 (/home/colin/code/rust/clap-ma)
    Finished dev [unoptimized + debuginfo] target(s) in 5.85s
     Running `target/debug/clap-ma -cc`
[            clap::build::app] 	App::_do_parse
[            clap::build::app] 	App::_build
[            clap::build::app] 	App::_propagate:clap-ma
[            clap::build::app] 	App::_derive_display_order:clap-ma
[            clap::build::app] 	App::_create_help_and_version
[            clap::build::app] 	App::_create_help_and_version: Building --help
[            clap::build::app] 	App::_create_help_and_version: Building --version
[clap::build::app::debug_asserts] 	App::_debug_asserts
[            clap::build::arg] 	Arg::_debug_asserts:clean
[            clap::build::arg] 	Arg::_debug_asserts:help
[            clap::build::arg] 	Arg::_debug_asserts:version
[         clap::parse::parser] 	Parser::get_matches_with
[         clap::parse::parser] 	Parser::_build
[         clap::parse::parser] 	Parser::_verify_positionals
[         clap::parse::parser] 	Parser::get_matches_with: Begin parsing '"-cc"' ([45, 99, 99])
[         clap::parse::parser] 	Parser::is_new_arg: "-cc":NotFound
[         clap::parse::parser] 	Parser::is_new_arg: arg_allows_tac=false
[         clap::parse::parser] 	Parser::is_new_arg: - found
[         clap::parse::parser] 	Parser::is_new_arg: starts_new_arg=true
[         clap::parse::parser] 	Parser::possible_subcommand: arg="-cc"
[         clap::parse::parser] 	Parser::get_matches_with: possible_sc=false, sc=None
[         clap::parse::parser] 	Parser::parse_short_arg: full_arg="-cc"
[         clap::parse::parser] 	Parser::parse_short_arg:iter:c
[         clap::parse::parser] 	Parser::parse_short_arg:iter:c: Found valid opt or flag
[         clap::parse::parser] 	Parser::check_for_help_and_version_char
[         clap::parse::parser] 	Parser::check_for_help_and_version_char: Checking if -c is help or version...
[         clap::parse::parser] 	Neither
[         clap::parse::parser] 	Parser::parse_flag
[    clap::parse::arg_matcher] 	ArgMatcher::inc_occurrence_of: arg=clean
[    clap::parse::arg_matcher] 	ArgMatcher::inc_occurrence_of: first instance
[            clap::build::app] 	App::groups_for_arg: id=clean
[         clap::parse::parser] 	Parser::parse_short_arg:iter:c
[         clap::parse::parser] 	Parser::parse_short_arg:iter:c: Found valid opt or flag
[         clap::parse::parser] 	Parser::check_for_help_and_version_char
[         clap::parse::parser] 	Parser::check_for_help_and_version_char: Checking if -c is help or version...
[         clap::parse::parser] 	Neither
[         clap::parse::parser] 	Parser::parse_flag
[    clap::parse::arg_matcher] 	ArgMatcher::inc_occurrence_of: arg=clean
[            clap::build::app] 	App::groups_for_arg: id=clean
[         clap::parse::parser] 	Parser::get_matches_with: After parse_short_arg Flag(clean)
[         clap::parse::parser] 	Parser::maybe_inc_pos_counter: arg = clean
[         clap::parse::parser] 	Parser::maybe_inc_pos_counter: is it positional?
[         clap::parse::parser] 	No
[            clap::build::app] 	App::groups_for_arg: id=clean
[         clap::parse::parser] 	Parser::remove_overrides
[         clap::parse::parser] 	Parser::remove_overrides:iter:clean
[      clap::parse::validator] 	Validator::validate
[         clap::parse::parser] 	Parser::add_defaults
[      clap::parse::validator] 	Validator::validate_conflicts
[      clap::parse::validator] 	Validator::validate_exclusive
[      clap::parse::validator] 	Validator::validate_exclusive:iter:clean
[      clap::parse::validator] 	Validator::gather_conflicts
[      clap::parse::validator] 	Validator::gather_conflicts:iter: id=clean
[            clap::build::app] 	App::groups_for_arg: id=clean
[      clap::parse::validator] 	Validator::validate_required: required=ChildGraph([])
[      clap::parse::validator] 	Validator::gather_requirements
[      clap::parse::validator] 	Validator::gather_requirements:iter:clean
[      clap::parse::validator] 	Validator::validate_required_unless
[      clap::parse::validator] 	Validator::validate_matched_args
[      clap::parse::validator] 	Validator::validate_matched_args:iter:clean: vals=[]
[      clap::parse::validator] 	Validator::validate_arg_num_vals
[      clap::parse::validator] 	Validator::validate_arg_values: arg="clean"
[      clap::parse::validator] 	Validator::validate_arg_requires:"clean"
[      clap::parse::validator] 	Validator::validate_arg_num_occurs: "clean"=2
[    clap::parse::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[]
Args {
    clean: true,
}
</code>
</pre>
</details>


---

_Label `T: bug` added by @fosskers on 2020-10-31 18:38_

---

_Label `C: derive macros` added by @pksunkara on 2020-10-31 20:41_

---

_Added to milestone `3.0` by @pksunkara on 2020-10-31 20:41_

---

_Comment by @fosskers on 2020-11-20 03:35_

I managed to satisfy my original requirements via the suggestion given here: https://github.com/clap-rs/clap/discussions/2192#discussioncomment-133916

We can probably close this issue, since what I was looking for was effectively already possible.

---

_Referenced in [fosskers/aura#671](../../fosskers/aura/pulls/671.md) on 2020-11-20 16:40_

---

_Comment by @pksunkara on 2021-05-26 10:37_

To resolve: `Vec<bool>` should not be treated as an arg taking values. Also, look into how `Option<bool>` performs.

---

_Comment by @epage on 2021-07-20 17:18_

I'd propose we "won't fix" this and instead point people to `#[clap(..., parse(from_occurrences))]`


Currently, we don't special case any compound `bool` types.

I'm trying to understand why/when someone would want one compared to `from_occurrences`:
- `Option<bool>` is redundant: we already know whether the flag is present or not, based on bool
- `Vec<bool>` will just be a variable number of `true`, only useful for the count.

As part of my holistic view for #1772 though I should call this out.

---

_Closed by @fosskers on 2021-10-21 21:05_

---

_Referenced in [clap-rs/clap#2993](../../clap-rs/clap/pulls/2993.md) on 2021-11-05 14:24_

---
