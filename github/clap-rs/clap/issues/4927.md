---
number: 4927
title: Add ability to remove a subcommand
type: issue
state: open
author: kvece
labels:
  - C-enhancement
assignees: []
created_at: 2023-05-20T23:51:18Z
updated_at: 2023-05-21T01:55:19Z
url: https://github.com/clap-rs/clap/issues/4927
synced_at: 2026-01-07T12:31:17-06:00
---

# Add ability to remove a subcommand

---

_Issue opened by @kvece on 2023-05-20 23:51_

### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the [open](https://github.com/clap-rs/clap/issues) and [rejected](https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed) issues

### Clap Version

master

### Describe your use case

Basically I am trying to make an interactive REPL

I decided to originally follow from the recipe provided in the cookbook, basically have a root command set with `multicall` and I all commands in the REPL are implemented as subcommands.

However, when the commands are the REPL are dynamic, I can add commands easily but removing commands that are no longer requires rebuilding the entire `Command` struct with the desired subcommand missing, which is rather tedious.

### Describe the solution you'd like

I just took the `mut_subcommand` function, copied it, and modified it to a `remove_subcommand` function that has the same functionality except without the callback and without placing a subcommand back into `self.subcommands`

### Alternatives, if applicable

The other option I considered was modifying the `subcommand` function that followed the builder pattern, but since I'm not sure why you would need to remove a command in a builder pattern, I thought it was easier to modify the struct rather than create a new one.

### Additional Context

_No response_

---

_Label `C-enhancement` added by @kvece on 2023-05-20 23:51_

---

_Referenced in [clap-rs/clap#4928](../../clap-rs/clap/pulls/4928.md) on 2023-05-20 23:52_

---

_Comment by @epage on 2023-05-21 00:43_

Could you expand on the use case for why commands are being added and removed during the lifetime of the REPL?

---

_Comment by @kvece on 2023-05-21 01:02_

Sure, picture an interactive CLI with a plugin system:
```
> load plugin
> # associated commands become available
> unload plugin
> # associated commands no longer available
```

An alternative design could be:
```
> use plugin
plugin> # opens a submenu with only the associated commands
plugin> back
> # associated commands no longer available
```

But this has the issue where switching back and forth between plugin commands is more tedious for the user (ideally user can load multiple plugins into namespace at once)

Another alternative would be to allow multiple at once:
```
> use plugin1
plugin1> # opens submenu command object with plugin1 commands added
plugin1> use plugin2
plugin1,plugin2> # opens another object with plugin2 added
plugin1,plugin2> unload plugin1    # now say plugin1 is no longer needed
plugin2> # now I have to start from the root Command and rebuild the object, current solution
```

---

_Comment by @kvece on 2023-05-21 01:15_

Or reference similar functionality in popular python module here: https://cmd2.readthedocs.io/en/stable/features/modular_commands.html

---

_Comment by @epage on 2023-05-21 01:55_

This isn't the right approach with clap's design.  clap expects everything to be added and then "builds".  Once the build happens, changes shouldn't be made (I'd like to enforce this within the type system but haven't found a satisfactory design yet).  Using this in a REPL to add / remove commands implies an existing instance is being reused.  As an alternative, you could recreate your `Command` on each interaction which will let you add the currently active plugins though I don't know if the cost for that would be reasonable.

For `cmd2`, it looks like they have an `ArgumentParsser` per command and I suspect that would be the right way to model this within your application.

---
