---
number: 2471
title: "Using `clap(global = true)` with clap_derive"
type: issue
state: closed
author: kbknapp
labels:
  - A-docs
assignees: []
created_at: 2021-05-07T17:28:59Z
updated_at: 2021-05-08T08:38:47Z
url: https://github.com/clap-rs/clap/issues/2471
synced_at: 2026-01-07T12:31:17-06:00
---

# Using `clap(global = true)` with clap_derive

---

_Issue opened by @kbknapp on 2021-05-07 17:28_

### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the existing issues

### Clap Version

3.0.0-beta.2

### Where?

clap_derive docs/examples

### What's wrong?

Using `clap(global = true)` has some oddities that should be documented better. Because if the child subcommand has no field defined for that parent's global argument, no warnings or errors are emitted. Additionally, if you *do* define the field in the child command, there is no need to add all the additional clap metadata, that's only required on the parent.

# Example

```rust
#[derive(Clap)]
struct Args {
    /// Some value
    #[clap(short, long, global = true)]
    value: String,
    #[clap(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand)]
enum Cmd {
    Foo(FooArgs),
}

#[derive(Clap)]
struct FooArgs { }
```

This compiles with no warnings/errors.

Now, obviously if I were to try to use a non-existent field `value` of `FooArgs`, Rust will not compile. Perhaps the user expected some macro magic would make that work? Regardless, the user could then copy/paste the whole field into the `FooArgs` struct, metadata and all:

```rust
#[derive(Clap)]
struct FooArgs {
    /// Some value
    #[clap(short, long, global = true)]
    value: String,
}
```

However, that's not necessary, and could actually lead to errors/confusion. All that is required is to add the field itself:

```rust
#[derive(Clap)]
struct FooArgs {
    value: String,
}
```

The help message will be correct (as defined by the parent command), and clap will parse `args foo --value bar` correctly.

It's a minor docs issue, but one that can be confusing.

### How to fix?

Put an example in the `examples/` dir, or call this out during the `Arg::global` docs. I believe all that's required to mention is that the target struct simply needs the field defined without all the clap metadata.

---

_Label `C: docs` added by @kbknapp on 2021-05-07 17:28_

---

_Comment by @kbknapp on 2021-05-07 17:51_

Actually I'm going to close this, as what I said isn't exactly correct. The sentiment is correct (we need better docs on the subject), but I'd say it's a low enough priority that it's not worth the open issue at the moment.

---

_Closed by @kbknapp on 2021-05-07 17:51_

---

_Comment by @pksunkara on 2021-05-08 08:38_

#2026 should solve the issue.

---
