---
number: 431
title: "Feature request: ArgGroup with SubCommand"
type: issue
state: closed
author: matthiasbeyer
labels: []
assignees: []
created_at: 2016-02-20T20:37:12Z
updated_at: 2018-08-02T03:29:48Z
url: https://github.com/clap-rs/clap/issues/431
synced_at: 2026-01-07T12:31:16-06:00
---

# Feature request: ArgGroup with SubCommand

---

_Issue opened by @matthiasbeyer on 2016-02-20 20:37_

Would it be possible to implement something like ArgGroup but only with the possibility to contain SubCommand support? So we can have either "Arg or Arg or SubCommand or Arg"?

Would be nice IMHO.

Thanks for writing clap! It is awesome!


---

_Comment by @kbknapp on 2016-02-22 05:41_

Thanks for the kind words :+1: 

It _would_ be possible, but I'm not sure the juice would be worth the squeeze because it would change the implementation for quite a few things internally. So I'm open to some discussion about it, and we can see if we can fit it in somehow or another.

Can you give an example of what you're trying to do, and perhaps there is another way? Sometimes just re-thinking parts of the CLI design suffice.

Thanks for suggesting this feature!


---

_Label `T: RFC / question` added by @kbknapp on 2016-02-22 05:46_

---

_Label `T: new feature` added by @kbknapp on 2016-02-22 05:46_

---

_Comment by @matthiasbeyer on 2016-02-22 06:59_

My use-case is rather simple. I have a program which either takes some data and puts it into a "store". The program should have two ways of creating new entries in the store:
1. From the raw presentation (like `cat $file | into-store --raw --stdin`)
2. By constructing it from the commandline (like `into-store entry --content "foo bar" --header foo=1`)

You can see, in the first example I'm simply using flags, in the second one I'm using a subcommand. That's my usecase; they should never appear in the same call.

Therefor it would be nice to be able to specify `either $arg or $subcommand`

Maybe even `either $arg or $subcommand or $arggroup` would be nice (where "or" is replaceable by "and")


---

_Comment by @kbknapp on 2016-02-22 07:53_

My personal opinion would be to just dispatch both those calls to the same handler method. i.e.

``` rust
let m = App::new("into-store")
    // ...
    .get_matches();

match m.subcommand() {
    ("entry", Some(sub_m)) => {
        handle_content(sub_m.value_of("content"));
    },
    // ...
    ("", None) => {
        // no subcommand used
        if m.is_present("raw") && m.is_present("stdin") {
            handle_content(/* read from stdin */);
        }
   }
}
```

Let me play some implementations of adding subcommands to groups and see how it interacts with the system a bit and I'll post back with some findings. It may be a day or so just due to free time, but I'll let you know!


---

_Comment by @matthiasbeyer on 2016-02-22 08:29_

This sounds awesome! Thanks for considering!


---

_Closed by @kbknapp on 2016-08-26 15:49_

---
