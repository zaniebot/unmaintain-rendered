---
number: 228
title: Various questions about implementation
type: issue
state: closed
author: WildCryptoFox
labels: []
assignees: []
created_at: 2015-09-06T14:10:22Z
updated_at: 2018-08-02T03:29:43Z
url: https://github.com/clap-rs/clap/issues/228
synced_at: 2026-01-07T12:31:16-06:00
---

# Various questions about implementation

---

_Issue opened by @WildCryptoFox on 2015-09-06 14:10_

Hey all, just reading through code and wondering why various decisions have been made. Oh and this list is unordered and just whatever thoughts appear while reading the code.
1. Why is validator `Rc`'d? Why not a `Box`?
2. Do `App` and `Arg` really need so many lifetimes? Can't they all just be bound to one? Why not just own `String`s?
3. How many methods are there to create an `App`? Yaml, builder macro #217, usage string, manual builder. Am I missing any?
4. Why is there a default subcommand of `help`? Why not at least be opt-in via settings?
5. No FAQ? One very expected question; why not use docopt or getopts?
6. Does the `Arg` need to know what group it is in? Shouldn't the groups be handled outside of the `Arg`?
7. `blacklist` for conflicts? Why not just `conflicts`?
8. Any thoughts for using rustfmt to clean up the formatting of the code? The `macros.rs` for one looks like it could be cleaned up at least visually.

---

That'll do for now, but I'll likely update this issue with more questions as I get deeper into the code.


---

_Label `T: RFC / question` added by @kbknapp on 2015-09-06 15:28_

---

_Comment by @kbknapp on 2015-09-06 15:57_

@james-darkfox Here's some of the answers, all great questions!

> Why is validator Rc'd? Why not a Box?

Originally `Box` was the idea. But if an `Arg` is marked as `global` (meaning it's cloned down the child subcommands). I couldn't find a good solution that would satisfy sane lifetime requirements. `Rc` was simply the easiest method to accomplish this until I've got some time to revisit it...or someone smarter than me changes it ;)

> Do App and Arg really need so many lifetimes? Can't they all just be bound to one? Why not just own Strings?

I wish they didn't. In the early days they were all bound to the `'static` lifetime. But there times when you want pull a piece of information for an `App` or `Arg` at runtime, and therefore can't use `'static`. There may be a way to specify that lifetimes of those particular settings are _at least_ as long as the `App` struct itself and cut them down...but I haven't played it lately.

The reason for not using owned Strings was to try and keep `clap` competitive in the performance department. 99% of the settings and such use a `'static` lifetime and don't need to be re-allocated in order to be used.

> How many methods are there to create an App? Yaml, builder macro #217, usage string, manual builder. Am I missing any?

To build an `App` there are two (Yaml, and builder pattern, your macro would make three).

To build an `Arg` there are three (Builder, usage string, Yaml, and your macro would make four).

> Why is there a default subcommand of help? Why not at least be opt-in via settings?

There is only a default subcommand of `help` when other subcommands have been defined manually. So it's opt-in(ish), being that you only get a `help` subcommand if you're actually using subcommands. Also, if the user defined a `help` subcommand themselves, the auto-generated one wouldn't be added (meaning it's only generated if the user hasn't defined one themselves). So the only missing thing I guess is allowing a user to _not_ have a `help` subcommand at all. If there are users who want a way to opt-out of `help` I can look at putting that in, just no one has asked for it.

> No FAQ? One very expected question; why not use docopt or getopts?

Adding a FAQ is a great idea! To answer that number one question I'd say it's two-fold:

**Reasons to use clap instead of doctopt or getopt**
- You want to implement as little of the CLI experience as possible, i.e. just define your valid args and continue on with your application, yet still get all the nice CLI features users expect.
- You need more performance than docopt provides
- You have complex requirements/conflicts between your various valid args
- You want to use subcommands
- You want some sort of custom validation built into the argument parsing process and not as part of your application (which allows for earlier failures, better error messages, more cohesive experience, etc.)

**Reasons to docopt instead clap**:
- You want automatic serialization of your arguments into Rust types
- You already have a docopt usage string already from another project or language 
- You simply like the docopt method better...sometimes it's just personal tastes :)

**Reasons to use getopts instead of clap**:
- You need absolutely as few allocations as possible and don't mind implementing nearly everything yourself
- You want to a portion of the arg parsing process to be very custom (i.e. again, implementing the details yourself)

> Does the Arg need to know what group it is in? Shouldn't the groups be handled outside of the Arg?

I agree. I think this part is confusing and will probably be removed at 2.x. The idea though is that the Arg doesn't know what group its in, it's just a shorthand for specifying which group to add this Arg to. I.e. you've already set up a group, but didn't add this Arg to it yet.

> blacklist for conflicts? Why not just conflicts?

That's just a legacy name that hasn't been refactored yet since it's internal and not public facing. 

> Any thoughts for using rustfmt to clean up the formatting of the code? The macros.rs for one looks like it could be cleaned up at least visually

Actually yes! :) I ran `rustfmt` against it a while back, but seeing all the news about `rustfmt` I think it's time to give it another run :+1: 

**Edit:** This is done as of #232 


---

_Referenced in [clap-rs/clap#229](../../clap-rs/clap/issues/229.md) on 2015-09-06 16:10_

---

_Referenced in [clap-rs/clap#230](../../clap-rs/clap/issues/230.md) on 2015-09-06 16:11_

---

_Comment by @WildCryptoFox on 2015-09-06 17:05_

Thanks! Answers are all good. One typo however:

> "You want automatic automatic serialization of your arguments into Rust types" - Reasons for docopt

I have two possible additions that could make clap even better:
- Interactive CLI. An interactive CLI or prompt, shares the same parsing requirements as command line arguments and if it were as easy as a single macro call to generate such prompt, clap could quickly become a direct goto for developers who need some interactive ability to play with their code. (This would likely need to be feature gated)
- Configurable template `trait DisplayApp` allowing for consumers to decide their own layout (especially useful for an interactive CLI)

---

Really like to see opinions for the above two suggestions.


---

_Comment by @kbknapp on 2015-09-06 18:19_

I like the prompt/interactive cli idea, but yeah I would assume this is be feature gated. If you want to work something up we can see how it fits within the rest of clap! 

For the template trait I'd need to see some examples of what you mean. I think I have an idea, but I could be way off too.


---

_Comment by @WildCryptoFox on 2015-09-06 23:13_

Docopt / posix getopt formats are two examples already featured.

Another example would be a straight list of subcommands where no arguments are even suitable.


---

_Comment by @kbknapp on 2015-09-07 20:09_

It's somewhat possible to do already, albiet in a slightly more manual but more flexible fashion.

For example, users can override the usage string do display a more doctopt/getopts style usage string (even multi lined) using `.usage()`. They can also add additional details after the help message using `.after_help()`. There is also the option to combine what `clap` calls Options and Flags into a single "Options" sections (a la docopt/getopts) using `AppSettings::UnifiedHelpMessage` variants. Finally, the user can just simply override the entire help message if that's what they wish to do.

Do you mean something beyond changing those aspects, or something else entirely?


---

_Comment by @kbknapp on 2015-09-07 20:38_

The [wiki page](https://github.com/kbknapp/clap-rs/wiki/FAQ) FAQ has been started based on the questions listed here. Once we have some good additions/suggestions, etc. I'll put a link to it in the readme as well as create  `FAQ.md`


---

_Referenced in [clap-rs/clap#235](../../clap-rs/clap/issues/235.md) on 2015-09-07 20:57_

---

_Comment by @WildCryptoFox on 2015-09-07 22:13_

I mean like having a trait that iterates over the object to create the textual structure itself. Then you only need to pass the `App` through such implementations and you'll get your desired string.


---

_Comment by @WildCryptoFox on 2015-09-09 09:34_

All questions answered. Respective spawned issues created. This issue is tracking nothing anymore.


---

_Closed by @WildCryptoFox on 2015-09-09 09:34_

---
