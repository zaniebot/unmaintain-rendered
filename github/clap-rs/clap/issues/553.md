---
number: 553
title: Show help for all subcommands with --all option?
type: issue
state: closed
author: rickystewart
labels: []
assignees: []
created_at: 2016-06-30T17:00:09Z
updated_at: 2018-08-02T03:29:51Z
url: https://github.com/clap-rs/clap/issues/553
synced_at: 2026-01-07T12:31:16-06:00
---

# Show help for all subcommands with --all option?

---

_Issue opened by @rickystewart on 2016-06-30 17:00_

I notice there is a `Hidden` option for subcommands to mark them as hidden from the default help screen.  I'd like some of my subcommands to be hidden by default, but I'd like there to be some option to display all subcommands on the help screen if the user wants to see them.  i.e. `help` should display only the information for the public subcommands, but `help --all` should display the information for every subcommand, including the hidden ones.  Does Clap support this use case?


---

_Renamed from "Show help for all subcommands with particular option?" to "Show help for all subcommands with --all option?" by @rickystewart on 2016-06-30 17:02_

---

_Comment by @kbknapp on 2016-06-30 17:35_

This can be done in your handling code. I'm not sure it's something I'd want to include in `clap` itself because it'd add a flag `--all` to all such interfaces which I don't think everyone would want.

To do this in your code, it'd be something along the lines of:

``` rust
extern crate clap;

use std::env;

use clap::{App, SubCommand, AppSettings};

fn main() {
    let mut app = build_app(true);

    // Use the get_matches_from_safe_borrow() which doesn't consume the app binding and doesn't
    // print the help message right away. Instead it returns an Err, saying the help was requested
    //
    // The unwrap_or_else with the e.exit() piece does all the familiar error messages upon a
    // failed parse.
    let m = app.get_matches_from_safe_borrow(env::args()).unwrap_or_else(|e| e.exit());

    // Now we check for either normal --help, or '--help and --all'
    if m.is_present("all") && m.is_present("help") {
        // Re-build the app, but don't hide the subcommands
        build_app(false).print_help().unwrap();
    } else if m.is_present("help") {
        // just re-use the app we already built, and print it's help.
        app.print_help().unwrap();
    }

    // Normal logic here...
}

fn build_app(hide_subcmds: bool) -> App<'static, 'static> {
    // First, we build any subcommands that may be hidden;
    let mut hidden = SubCommand::with_name("hidden");
    hidden = if hide_subcmds {
        hidden.setting(AppSettings::Hidden)
    } else {
        hidden
    };

    // Build the app like normal, but store with a let binding because we're going to re-use it
    //
    // The only difference is we add a `--help` arg so that clap thinks we're handling help
    // messages ourselves
    App::new("fake")
        .args_from_usage("    --all  'Show all subcommands in help message'
                          -h, --help 'Displays this help message'") // Simply needs a long
                                                                    // of --help for this
                                                                    // to work
        .subcommand(SubCommand::with_name("test"))
        .subcommand(hidden)
}
```


---

_Comment by @kbknapp on 2016-06-30 17:36_

You can try that out, but if you run `prog --help` it prints the help, or if you run `prog --help --all` it prints the help with all the subcommands un-hidden.


---

_Label `T: RFC / question` added by @kbknapp on 2016-06-30 17:37_

---

_Comment by @joshtriplett on 2016-07-04 12:31_

Rather than adding a separate option, I've often seen this done with `--help-all`, or occasionally `--help -v` if the program already has a "verbose" option.


---

_Closed by @kbknapp on 2016-08-21 19:47_

---
