---
number: 5700
title: "feat(derive): derive `clap::Args` for enum types"
type: pull_request
state: open
author: ysndr
labels: []
assignees: []
base: master
head: derive-arg-groups
created_at: 2024-08-25T16:42:03Z
updated_at: 2025-05-31T13:53:02Z
url: https://github.com/clap-rs/clap/pull/5700
synced_at: 2026-01-07T12:31:17-06:00
---

# feat(derive): derive `clap::Args` for enum types

---

_Pull request opened by @ysndr on 2024-08-25 16:42_

Implement `derive(clap::Args)` support for enum types, where each variant is a mutually exclusive `ArgGroup`.
Relevant discussion and motivation for this PR is in #2621.

-----

Impl notes:

At the moment this is a rough initial implementation.

* It only supports `Named` / struct like enum variants such as this:

```rust
#[derive(clap::Args, Clone, Debug, PartialEq, Eq)]
enum Source {
    A {
        #[arg(short)]
        a: bool,
        #[arg(long)]
        aaa: bool,
    },
    B {
        #[arg(short)]
        b: bool,
    },
}
```

* it has issues with determining a default when neither branch matches explicitly
* it's not fully covered with tests
* parts of it are frankensteined together from the `subcommand` impl and deriving from structs

Regardless this is a dear feature to me so i'm looking for some guidance to polish this into completion.




---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:94 on 2024-08-25 17:02_

Restricting this to named enums only, allows to reuse the struct codegen with little modification.

`Unnamed` variants, with a single item might somehow dispatch the parsing bits to the contained Type and _somehow_ set the group conflicts using `ArgGroup::mut_group` on the augment side and ??? on the from arg matches (that might simply forward?).

* `Unit` variants need to be parsed as flags?
* What about `enum Something { Variant(String) }` would we expect this to parse as 1) a positional, 2) a flag, 3) not at all bc we cant forward to `String`s implementations?

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:354 on 2024-08-25 17:04_

Not super clean to sqeeze this in here esp, since this is also used by the `subcommand` deriver, but i tried to avoid rewriting the entire method for this.

---

_Review comment by @ysndr on `clap_derive/src/item.rs`:73 on 2024-08-25 17:07_

this method is basically a copy of `from_subcommand_enum_variant`.
I'm not yet entirely clear if that is sensible since my picture of what `Item` is is still somewhat blurry.

---

_Review comment by @ysndr on `flake.nix`:1 on 2024-08-25 17:08_

don't mind this it just helps me get a rust compiler using nix...
will be removed before this is ready to go anywhere

---

_@ysndr reviewed on 2024-08-25 17:09_

---

_@ysndr reviewed on 2024-08-25 17:35_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:142 on 2024-08-25 17:35_

i guess this might fail if the current variant is different, should it be possible to "change" variants using `update_from_arg_matches_mut`?

---

_@ysndr reviewed on 2024-08-25 17:39_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:183 on 2024-08-25 17:39_

we actually _do_ get here if neither variant was explcitly constructed.
In a way that makes sense, if all variants have defaultable arguments, either is a valid candidate. However I cant decide if that's a conflict or resolvable by defining a default varaint for such situations

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:142 on 2024-08-25 17:49_

This should probably be an error, or instead of trying to update we'd attempt to parse all fields of the "other" variant and replace self with that.

---

_@ysndr reviewed on 2024-08-25 17:49_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:142 on 2024-08-25 17:51_

for a slightly more concrete discussion:
this currently generates:

```rust
fn update_from_arg_matches_mut(
    &mut self,
    __clap_arg_matches: &mut clap::ArgMatches,
) -> ::std::result::Result<(), clap::Error> {
    #![allow(deprecated)]
    if __clap_arg_matches.contains_id("A") {
        let Source::A { a, aaa } = self else {
            unreachable!();
        };
        if __clap_arg_matches.contains_id("a") {
            *a = __clap_arg_matches.remove_one::<bool>("a").ok_or_else(|| {
                clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    concat!("The following required argument was not provided: ", "a"),
                )
            })?
        }
        if __clap_arg_matches.contains_id("aaa") {
            *aaa = __clap_arg_matches
                .remove_one::<bool>("aaa")
                .ok_or_else(|| {
                    clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        concat!("The following required argument was not provided: ", "aaa"),
                    )
                })?
        };
    }
    if __clap_arg_matches.contains_id("B") {
        let Source::B { b } = self else {
            unreachable!();
        };
        if __clap_arg_matches.contains_id("b") {
            *b = __clap_arg_matches.remove_one::<bool>("b").ok_or_else(|| {
                clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    concat!("The following required argument was not provided: ", "b"),
                )
            })?
        };
    }
    ::std::result::Result::Ok(())
}
```

for my test enum:

```rust
#[derive(clap::Args, Clone, Debug, PartialEq, Eq)]
enum Source {
    A {
        #[arg(short)]
        a: bool,
        #[arg(long)]
        aaa: bool,
    },
    B {
        #[arg(short)]
        b: bool,
    },
}
```

---

_@ysndr reviewed on 2024-08-25 17:51_

---

_@epage reviewed on 2024-08-26 17:53_

---

_Review comment by @epage on `tests/derive/groups.rs`:292 on 2024-08-26 17:53_

When adding a test commit separate from a feature, it 
needs to still pass tests / compile.  I'm assuming this commit does neither. 

---

_@ysndr reviewed on 2024-08-26 17:57_

---

_Review comment by @ysndr on `tests/derive/groups.rs`:292 on 2024-08-26 17:57_

How would i add a test that does compile for a thing that doesn't yet compile, or where the subject of the PR is allowing these constructs to compile in the first place?


---

_@epage reviewed on 2024-08-26 18:03_

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:94 on 2024-08-26 18:03_

I'm fine with scoping the first PR toNamed variants.  We should have compile error tests for all of the other kinds of variants.

I could see soon after support single-element tuple variants with `#[command(flatten)] Variant(MoreArgs)` to avoid the need for `Variant { #[command(flatten)] args: MoreArgs }`.  I'm assuming supporting specifically that wouldn't be too bad.

Longer term...

`Unit` variant should probably be discussed in the issue.  My first guess is to use it as an "else" case.

For other single-element tuples, I see it working just like a field.  They are positional by default and need `#[arg(short, long)]` on the variant to change it to something else.  We'd use `value_parser!` to understand what to do with the type inside of the variant.

For N-element tuples, we have an issue for supporting those on fields and I'd point to that for variants as well.

---

_@epage reviewed on 2024-08-26 18:05_

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:142 on 2024-08-26 18:05_

I would look to subcommands for a starting point in designing how to model this.

I also am really tempted to remove all of the `update` code...

---

_@ysndr reviewed on 2024-08-26 18:09_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:94 on 2024-08-26 18:09_

that all makes sense in my book.
I'm still getting familiar with `Item` and the parsing around it where Named variants were just the closest to intuitively scrape together.
Happy to look into that soon after.

---

_@epage reviewed on 2024-08-26 18:10_

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:183 on 2024-08-26 18:10_

If the user has an `Option<Enum>`, we'll check if the group is present and do `None` if it isn't, so this is only a problem with `Enum`.  I lean towards hand constructing a clap error like we do if you have `#[arg(required = False)] String`.  If we make unit variants a fallback (or add a fallback attribute). then users can avoid the error here.

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:110 on 2024-08-26 18:12_

Why are we collecting and manually specifying conflicts rather than having `group.multiple(false)`?

There are bugs in nested group support but we should instead focus on those.

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:354 on 2024-08-26 18:13_

This goes away if we rely on groups, rather than conflicts

---

_Review comment by @epage on `clap_derive/src/item.rs`:73 on 2024-08-26 18:14_

`Item` is a mess.  It is a storage for all of our highlevel attribute information for a single type, field, variant, etc.  We use the same type for all of those and for whichever trait or attribute type is used.

Making this function fits exactly within the current model

---

_@epage reviewed on 2024-08-26 18:14_

---

_@epage reviewed on 2024-08-26 18:24_

---

_Review comment by @epage on `tests/derive/groups.rs`:292 on 2024-08-26 18:24_

"it depends"

Let's step back to the goals of why we encourage tests in a commit before the feature
- Help test the tests (when fixing a bug, did the tests actually need to change?)
- Through a commit's diff, making it clear to reviewers and the wider community what the intended behavior is

All of this is trivial when its a bug fix to help output.  You show the existing behavior in the tests, then change the test when you change the behavior.

When the behavior doesn't exist yet, your options are
- Just don't do this and have the test added in the commit.
- Capture the feature failing spectacularly
- Find the closest parallel feature and test that

The ideal is the last but sometimes there isn't always a close enough parallel and it can take the most work. 

As an example of the last, take https://github.com/rust-lang/cargo/pull/14435/commits.  This adds a new feature to Cargo.  Originally, the test commit used the new features which didn't exist and errored out quickly.  The commit that implemented the feature then made them not error.  This was still more helpful than having them in the same commit because I only had to review the test output and not all of the test.  However, I found a parallel feature and suggested it to the contributor.  The tests are now much easier to see what the intended behavior is.

Thats easy when its all textual output and you aren't dealing with compile errors.  One option is to write the tests with structs, rater than enums.  The commit that adds the feature could also switch the structs to enums, causing some cases to still work while other cases will error.

That might or might not be worth it.  If that seems like it will be too much or not show enough, feel free to say so, squash the commits, and move on.

---

_@ysndr reviewed on 2024-08-26 18:39_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:110 on 2024-08-26 18:39_

Ah specify multiple(false) for the "outer" group generated for the enum itself?
Guess that could work.
I explicitly stated the conflicts more out of intuition and reading that nested groups are behaving weirdly.

---

_@ysndr reviewed on 2024-08-26 18:40_

---

_Review comment by @ysndr on `clap_derive/src/item.rs`:73 on 2024-08-26 18:40_

Good to know, is there any better documentation on `Item` that I can read up on?

---

_Review comment by @epage on `clap_derive/src/item.rs`:73 on 2024-08-26 18:45_

Not really.  A lot of this is ad hoc.  It'd be good to clean up at some point.

---

_@epage reviewed on 2024-08-26 18:45_

---

_@ysndr reviewed on 2024-08-28 21:32_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:110 on 2024-08-28 21:32_

So to elaborate on "behaving weirdly", adding a group as an argument of a group doesnt seem to work at all currently

if i build something like this:
```
Command::new()
	.arg(clap::Arg::new("a") ...)
	.arg(clap::Arg::new("b") ...)
	.group(clap::ArgGroup("A").args(["a"])
	.group(clap::ArgGroup("B").args(["b"])
	.group(clap::ArgGroup("Outer").args(["A", "B"])
```

i get a runtime error: `Command clap: Argument group 'Outer' contains non-existent argument 'A'`.
Before I'm digging into the ArgGroup parser which seems to specifically address _args_ (rather than _args or groups_), i'm looking to confirm that this is indeed how we would want to specify nested groups to begin with.

-----------

Continue reading here if i haven't gone astray yet.

From thereon i'm looking at `clap_builder::parser::validator::gather_arg_direct_conflicts` which would recursively resolve all ancestor chains, and then from the root(s) down check each group whether it is a `multiple == false` group, and if it is add all args from other branches not on the current path as conflicts; or in pseudocode:


```
conflicts(arg_id: &Id, path: Vec<&Id>, conf: &mut Vec<Id>)

parent_id = path[-1] ? arg_id
for group in groups_for_arg(parnt_id) {
	
	for conflict in group.conflicts {
		if conflict.is_group {
			for member in members_recursive_ignore_path(path, group) {
				conf.push(member.id)
			}
		} else {
			conf.push(conflict.id)
		}
	}

	if !group.multiple {
		for member in members_recursive_ignore_path(path, group) {
			conf.push(member.id)
		}
	}

	path = path.clone()
	path.push(group.id)
	conflicts(arg_id, path, conf)
}
```

that is if the goal is to support arbitrary nesting
I'm not too happy with the amount of potential duplicates iff groups are densely nested.
Also keep calling `groups_for_arg` (or the impl of it) may hold potential for optimization down the road.

I believe a similar impl is also necessary for `require`ing with nested groups.

---

_@epage reviewed on 2024-08-29 21:48_

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:110 on 2024-08-29 21:48_

Oh wow, I thought we supported that.  There was some case where we had a bug related to `ArgGroup`s and I thought we had broader support for `ArgGroup`s than we apparently do (which also means I blocked #4697 on the wrong thing...)

I would like for this to move forward with groups, rather than conflicts, so we make sure we stabilize the right semantics.  So that means we need nested groups first...

One approach
- Deprecate `ArgGroup::arg` and `ArgGroup::args` and add `ArgGroup::member` or `ArgGroup::child`
- Update the assertions related to ensuring group members are present
- Add associated tests to make sure nested arg groups work, fixing bugs along the way

If someone wants to take this on, this should be its own PR.

---

_@ysndr reviewed on 2024-08-29 22:21_

---

_Review comment by @ysndr on `clap_derive/src/derives/args.rs`:110 on 2024-08-29 22:21_

I'd be up to look into that.
Do you think my understanding of conflict detection aligns with your intended changes to arggroup?
If not, how/where could we plan this in more detail than 3 bullet points?

---

_@epage reviewed on 2024-08-30 20:31_

---

_Review comment by @epage on `clap_derive/src/derives/args.rs`:110 on 2024-08-30 20:31_

Created #5711.  I don't have more specific guidance at this time.  In general, a child group should behave like a child arg.  I don't more more specific guidance than that at this time.

---
